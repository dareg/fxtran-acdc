#!/usr/bin/perl -w

package task;

use strict;

my $count = 0;

sub new
{
  my $class = shift;
  my %args = @_;

  my $self = bless {id => $count++, @_}, $class;

if (1) {
  my $bash = sprintf ('cmd.%3.3d.sh', $self->{id});

  'FileHandle'->new (">$bash")->print (<< "EOF");
#!/bin/bash

@{ $args{cmd} }

EOF

  chmod (0755, $bash);
}

  return $self;
}

sub run
{
  my $self = shift;
  my %args = @_;

  my @cmd = @{ $self->{cmd} };

  $self->{mess} = `@cmd 2>&1`;
  $self->{code} = $?;

  if ($args{final}) 
    {
      $self->final ();
    }
}

sub final
{
  my $self = shift;

  print $self->{mess};

  if ($self->{code})
    {
      die ("Command `@{ $self->{cmd} }' failed");
    }
}

package main;

use strict;
use FileHandle;
use Data::Dumper;
use File::Temp;
use File::Basename;
use File::Spec;
use File::Copy;
use FindBin qw ($Bin);
use lib "$Bin/../lib";
use Cwd;

use queue;

my $f90 = shift; 

sub runCommand
{
  my @cmd = @_;

  my $task = 'task'->new (cmd => \@cmd);

  $task->run (final => 1);
}

sub concatenateSource
{
  my %args = @_;

  my @opts = @{ $args{opts} };
  my ($obj, $f90, $F90) = @args{qw (obj f90 F90)};

  my $fho;

  for my $f ($F90, sort <*.F90>)
    {
      $fho ||= 'FileHandle'->new ('>' . &basename ($F90));
      my $code = do { my $fh = 'FileHandle'->new ("<$f"); local $/ = undef; <$fh> };
      $fho->print ($code);
      $fho->print ("\n" x 3);
    }

  $fho->close ();

  &runCommand ($f90, @opts, -o => $obj, &basename ($F90));
}

sub concatenateObject
{
  my %args = @_;

  my @opts = @{ $args{opts} };
  my ($obj, $f90, $F90) = @args{qw (obj f90 F90)};

  my @obj;

  my $q = 'queue'->new (nthread => 4);

  my @F90 = sort <*.F90>;
  unshift (@F90, $F90) if ($F90);

  for my $i (0 .. $#F90)
    {
      my $f = $F90[$i];
      my $task = 'task'->new (cmd => [$f90, @opts, $f]);
      if (($i == 0) || (! $args{parallel}))
        {
          $task->run (final => 1);
        }
      else
        {
          $q->push ($task);
        }
      (my $obj = &basename ($f)) =~ s/\.F90$/.o/o;
      unshift (@obj, $obj);
    }

  $q->tail (callback => sub { $_[0]->final () });

  $q->finish ();

  if (scalar (@obj) == 1)
    {
      rename ($obj[0], $obj);
    }
  else
    {
      my @ld = ('ld', '-r', '-o', $obj, @obj);
      &runCommand (@ld);
    }

}

sub openacc
{
  shift;
  my %args = @_;

  my @cmd = @{ $args{cmd} };
  my $F90 = $args{F90};

  push @cmd, '--merge-interfaces', '--dir', '.';

  &runCommand (@cmd, $F90);

  &concatenateObject (%args);
}

sub generateStructureMethods
{
  shift;
  my %args = @_;

  my @cmd = @{ $args{cmd} };
  my $F90 = $args{F90};
  my $dir = $args{dir};

  my $pack = $ENV{TARGET_PACK};

  $dir = $pack if ($pack);

  push @cmd, 
    '--types-fieldapi-dir', "$dir/types-fieldapi",
    '--types-constant-dir', "$dir/types-constant",
    '--sorted';

  &runCommand (@cmd, $F90);

  if (grep { $_ eq '--type-bound-methods' } @cmd)
    {
      delete $args{F90};
      $args{parallel} = 1;
    }

  &concatenateObject (%args);

}

sub pointerParallel
{
  shift;
  my %args = @_;

  my @cmd = @{ $args{cmd} };
  my $F90 = $args{F90};
  my $dir = $args{dir};
  my @opts = @{ $args{opts} };

  my $pack = $ENV{TARGET_PACK};

  $dir = $pack if ($pack);

  my @inc = grep { m/^-I/ } @opts;

  for my $dt ('types-fieldapi', 'types-constant')
    {
      if (-d "$dir/$dt")
        {
          &runCommand ('cp', '-r', "$dir/$dt", "$dt");
        }
    }

  &runCommand ("$Bin/fieldRB.pl");
  &runCommand ("$Bin/linkTypes.pl");

  push @cmd, 
    '--types-fieldapi-dir', "types-fieldapi",
    '--types-constant-dir', "types-constant",
    '--dir', '.', '--merge-interfaces', @inc;

  &runCommand (@cmd, $F90);

  &concatenateObject (%args);
}

sub outline1
{
  shift;
  my %args = @_;

  my @cmd = @{ $args{cmd} };
  my $F90 = $args{F90};
  my @opts = @{ $args{opts} };

  my $pack = $ENV{TARGET_PACK};

  &runCommand (@cmd, $F90);

  delete $args{F90};

  &concatenateObject (%args, parallel => 1);
}

my $c = grep { $_ eq '-c' } @ARGV;

unless ($c)
  {
    exec ($f90, @ARGV);
  }

# Absolute path for includes

my @argv;

for (my $i = 0; $i < scalar (@ARGV); $i++)
  {
    if ($ARGV[$i] eq '-I')
      {
        push @argv, '-I' . 'File::Spec'->rel2abs ($ARGV[$i+1]);
        $i++;
      }
    elsif (my ($inc) = ($ARGV[$i] =~ m/^-I(.*)$/o))
      {
        push @argv, '-I' . 'File::Spec'->rel2abs ($inc);
      }
    else
      {
        push @argv, $ARGV[$i];
      }
  }

@ARGV = @argv;

my @F90 = grep { m/\.(?:F90|F)$/io } @ARGV;
my @opts = grep { ! m/\.(?:F90|F)$/io } @ARGV;

my $dir = &cwd ();

FILE: for my $F90 (@F90)
  {
    my $tmp = 'File::Temp'->newdir (CLEANUP => 0, DIR => "$ENV{GPUPACK_PREFIX}/tmp");
    chdir ($tmp);

    $F90 = 'File::Spec'->rel2abs ($F90, $dir);

    (my $obj = $F90) =~ s/\.(?:F90|F)$/.o/io;

    push @opts, "-I$dir";

    my @text = do { my $fh = 'FileHandle'->new ("<$F90"); <$fh> };

    if (my ($ACDC) = map { m/^\!\$ACDC (\S.*)$/o ? ($1) : () } @text)
      {
        my ($method) = ($ACDC =~ m/^(\w+)/o);
        my @cmd = split (m/\s+/o, $ACDC);
        $cmd[0] = "$Bin/$cmd[0]";

        if ('main'->can ($method))
          {
            'main'->$method (obj => $obj, f90 => $f90, F90 => $F90, opts => \@opts, cmd => \@cmd, dir => $dir);
            next FILE;
          }

      }

NORMAL:

    &runCommand ($f90, @opts, -o => $obj, $F90);
  }

for my $mod (<*.mod>, <*.smod>)
  {
    &move ($mod, "$dir/$mod");
  }



