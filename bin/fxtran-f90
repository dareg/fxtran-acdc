#!/usr/bin/perl -w

use strict;
use Getopt::Long;
use FileHandle;
use Data::Dumper;
use File::Temp;
use File::Basename;
use File::Spec;
use File::Copy;
use FindBin qw ($Bin);
use lib "$Bin/../lib";
use Cwd;

use Bt;

use queue;
use task;

sub runCommand
{
  my %args = @_;
  my @cmd = @{ $args{cmd} };

  my $task = 'task'->new (cmd => \@cmd, debug => $args{debug});

  $task->run (final => 1);
}

sub runF90Compiler
{
  my %args = @_;
  return if ($args{dryrun});
  &runCommand (%args);
}

sub concatenateSource
{
  my %args = @_;

  my @f90flags = @{ $args{f90flags} };
  my ($obj, $f90compiler, $F90) = @args{qw (obj f90compiler F90)};
  my $opts = $args{opts};

  my $fho;

  for my $f ($F90, sort <*.F90>)
    {
      $fho ||= 'FileHandle'->new ('>' . &basename ($F90));
      my $code = do { my $fh = 'FileHandle'->new ("<$f"); local $/ = undef; <$fh> };
      $fho->print ($code);
      $fho->print ("\n" x 3);
    }

  $fho->close ();

  &runF90Compiler (cmd => [$f90compiler, @f90flags, -o => $obj, &basename ($F90)], %$opts);
}

sub concatenateObject
{
  my %args = @_;

  my @f90flags = @{ $args{f90flags} };
  my ($obj, $f90compiler, $F90) = @args{qw (obj f90compiler F90)};
  my $opts = $args{opts};

  return if ($opts->{dryrun});

  my @obj;

  my $q = 'queue'->new (nthread => 4);

  my @F90 = sort <*.F90>;
  unshift (@F90, $F90) if ($F90);

  for my $i (0 .. $#F90)
    {
      my $f = $F90[$i];
      my $task = 'task'->new (cmd => [$f90compiler, @f90flags, $f], debug => $opts->{debug});
      if (($i == 0) || (! $args{parallel}))
        {
          $task->run (final => 1);
        }
      else
        {
          $q->push ($task);
        }
      (my $obj = &basename ($f)) =~ s/\.F90$/.o/o;
      unshift (@obj, $obj);
    }

  $q->tail (callback => sub { $_[0]->final () });

  $q->finish ();

  if (scalar (@obj) == 1)
    {
      rename ($obj[0], $obj);
    }
  else
    {
      my @ld = ('ld', '-r', '-o', $obj, @obj);
      &runCommand (cmd => \@ld, %$opts);
    }

}

sub getopt_s
{
  my ($opts, $name) = @_;
  return $opts->{$name} ? ("--$name", $opts->{$name}) : ();
}

sub getopt_f
{
  my ($opts, $name) = @_;
  return $opts->{$name} ? ("--$name") : ();
}

sub openacc
{
  shift;
  my %args = @_;

  my @cmd = @{ $args{cmd} };
  my $F90 = $args{F90};
  my $opts = $args{opts};

  push @cmd, 
    &getopt_s ($opts, 'cycle'), 
    &getopt_f ($opts, 'interface'),
    &getopt_f ($opts, 'merge-interfaces'),
    '--dir', '.';

  &runCommand (cmd => [@cmd, $F90], %$opts);

  &concatenateObject (%args);
}

sub generateStructureMethods
{
  shift;
  my %args = @_;

  my @cmd = @{ $args{cmd} };
  my $F90 = $args{F90};
  my $opts = $args{opts};

  push @cmd, 
    '--types-fieldapi-dir', $opts->{'types-fieldapi-dir'},
    '--types-constant-dir', $opts->{'types-constant-dir'},
    &getopt_f ($opts, 'sorted');

  &runCommand (cmd => [@cmd, $F90], %$opts);

  if (grep { $_ eq '--type-bound-methods' } @cmd)
    {
      delete $args{F90};
      $args{parallel} = 1;
    }

  &concatenateObject (%args);

}

sub pointerParallel
{
  shift;
  my %args = @_;

  my @cmd = @{ $args{cmd} };
  my $F90 = $args{F90};
  my @f90flags = @{ $args{f90flags} };
  my $opts = $args{opts};

  my @inc = grep { m/^-I/ } @f90flags;

  my $tmp = 'File::Temp'->newdir ();

  my @dir;

  for my $dir (qw (types-fieldapi-dir types-constant-dir))
    {
      if (-d $opts->{$dir})
        {
          &runCommand (cmd => ['cp', '-r', $opts->{$dir}, "$tmp/$dir"], %$opts);
        }
    }

  &runCommand (cmd => ["$Bin/fieldRB.pl", '--types-fieldapi-dir', "$tmp/types-fieldapi-dir"], %$opts);
  &runCommand (cmd => ["$Bin/linkTypes.pl", '--types-fieldapi-dir', "$tmp/types-fieldapi-dir"], %$opts);

  push @cmd, 
    &getopt_s ($opts, 'cycle'),
    '--types-fieldapi-dir', "$tmp/types-fieldapi-dir",
    '--types-constant-dir', "$tmp/types-constant-dir",
    '--dir', '.', 
    &getopt_f ($opts, 'merge-interfaces'), 
    @inc;

  &runCommand (cmd => [@cmd, $F90], %$opts);

  &concatenateObject (%args);
}

sub outline1
{
  shift;
  my %args = @_;

  my @cmd = @{ $args{cmd} };
  my $F90 = $args{F90};
  my @f90flags = @{ $args{f90flags} };
  my $opts = $args{opts};

  &runCommand (cmd => [@cmd, $F90], %$opts);

  delete $args{F90};

  &concatenateObject (%args, parallel => 1);
}

my %opts = ('types-constant-dir' => '.', 'types-fieldapi-dir' => '.');
my @opts_f = qw (debug interface dryrun help sorted merge-interfaces);
my @opts_s = qw (cycle dir tmp types-fieldapi-dir types-constant-dir);

&GetOptions
(
  (map { ($_, \$opts{$_}) } @opts_f),
  (map { ("$_=s", \$opts{$_}) } @opts_s),
);

if ($opts{help})
  {
    print
     "Usage: " . &basename ($0) . "\n" .
      join ('', map { "  --$_\n" } @opts_f) .
      join ('', map { "  --$_=...\n" } @opts_f) .
     "\n";
    exit (0);
  }

my $f90compiler = shift (@ARGV);

my $c = grep { $_ eq '-c' } @ARGV;

unless ($c)
  {
    exec ($f90compiler, @ARGV) unless ($opts{dryrun});
    exit (0);
  }


# Absolute path for includes

my @argv;

for (my $i = 0; $i < scalar (@ARGV); $i++)
  {
    if ($ARGV[$i] eq '-I')
      {
        push @argv, '-I' . 'File::Spec'->rel2abs ($ARGV[$i+1]);
        $i++;
      }
    elsif (my ($inc) = ($ARGV[$i] =~ m/^-I(.*)$/o))
      {
        push @argv, '-I' . 'File::Spec'->rel2abs ($inc);
      }
    else
      {
        push @argv, $ARGV[$i];
      }
  }

@ARGV = @argv;

my @F90 = grep { m/\.(?:F90|F)$/io } @ARGV;
my @f90flags = grep { ! m/\.(?:F90|F)$/io } @ARGV;

my $cwd = &cwd ();

FILE: for my $F90 (@F90)
  {
    my $dir = '.';

    if ($opts{dir})
      {
        $dir = $opts{dir};
      }
    elsif ($opts{tmp})
      {
        $dir = 'File::Temp'->newdir (CLEANUP => ! $opts{debug}, DIR => $opts{tmp});
      }

    chdir ($dir);

    $F90 = 'File::Spec'->rel2abs ($F90, $cwd);

    (my $obj = $F90) =~ s/\.(?:F90|F)$/.o/io;

    push @f90flags, "-I$cwd";

    my @text = do { my $fh = 'FileHandle'->new ("<$F90"); <$fh> };

    if (my ($ACDC) = map { m/^\!\$ACDC (\S.*)$/o ? ($1) : () } @text)
      {
        goto NORMAL if ($ACDC =~ m/\{\s*$/o);

        my ($method) = ($ACDC =~ m/^(\w+)/o);
        my @cmd = split (m/\s+/o, $ACDC);
        $cmd[0] = "$Bin/$cmd[0]";

        die ("Method `$method' was not found")
          unless ('main'->can ($method));

        'main'->$method 
        (
          obj => $obj, f90compiler => $f90compiler, F90 => $F90, opts => \%opts,
          f90flags => \@f90flags, cmd => \@cmd, cwd => $cwd,
        );

        next FILE;

      }

NORMAL:

    &runF90Compiler (cmd => [$f90compiler, @f90flags, -o => $obj, $F90], %opts);
  }

for my $mod (<*.mod>, <*.smod>)
  {
    &move ($mod, "$cwd/$mod");
  }



