MODULE UTIL_TEDYN_MOD

USE YEMDYN, ONLY : TEDYN

INTERFACE SAVE
MODULE PROCEDURE SAVE_TEDYN
END INTERFACE

INTERFACE LOAD
MODULE PROCEDURE LOAD_TEDYN
END INTERFACE

INTERFACE COPY
MODULE PROCEDURE COPY_TEDYN
END INTERFACE

INTERFACE HOST
MODULE PROCEDURE HOST_TEDYN
END INTERFACE

     
INTERFACE CRC64
MODULE PROCEDURE CRC64_TEDYN
END INTERFACE

INTERFACE WIPE
MODULE PROCEDURE WIPE_TEDYN
END INTERFACE

INTERFACE SIZE
MODULE PROCEDURE SIZE_TEDYN
END INTERFACE


CONTAINS

SUBROUTINE SAVE_TEDYN (KLUN, YD)

IMPLICIT NONE
INTEGER, INTENT (IN) :: KLUN
TYPE (TEDYN), INTENT (IN), TARGET :: YD
LOGICAL :: LRDIDIVE, LRDIGFLE, LRDIPDE, LRDISPE, LRDITE, LRDIVDE, LRDIVORE, LRDSDIVE, LRDSVDE, LRDSVORE
LOGICAL :: LREFILD, LREFILV
LRDIVORE = ALLOCATED (YD%RDIVORE)
WRITE (KLUN) LRDIVORE
IF (LRDIVORE) THEN
  WRITE (KLUN) LBOUND (YD%RDIVORE)
  WRITE (KLUN) UBOUND (YD%RDIVORE)
  WRITE (KLUN) YD%RDIVORE
ENDIF
LRDIDIVE = ALLOCATED (YD%RDIDIVE)
WRITE (KLUN) LRDIDIVE
IF (LRDIDIVE) THEN
  WRITE (KLUN) LBOUND (YD%RDIDIVE)
  WRITE (KLUN) UBOUND (YD%RDIDIVE)
  WRITE (KLUN) YD%RDIDIVE
ENDIF
LRDITE = ALLOCATED (YD%RDITE)
WRITE (KLUN) LRDITE
IF (LRDITE) THEN
  WRITE (KLUN) LBOUND (YD%RDITE)
  WRITE (KLUN) UBOUND (YD%RDITE)
  WRITE (KLUN) YD%RDITE
ENDIF
LRDIGFLE = ALLOCATED (YD%RDIGFLE)
WRITE (KLUN) LRDIGFLE
IF (LRDIGFLE) THEN
  WRITE (KLUN) LBOUND (YD%RDIGFLE)
  WRITE (KLUN) UBOUND (YD%RDIGFLE)
  WRITE (KLUN) YD%RDIGFLE
ENDIF
LRDIPDE = ALLOCATED (YD%RDIPDE)
WRITE (KLUN) LRDIPDE
IF (LRDIPDE) THEN
  WRITE (KLUN) LBOUND (YD%RDIPDE)
  WRITE (KLUN) UBOUND (YD%RDIPDE)
  WRITE (KLUN) YD%RDIPDE
ENDIF
LRDIVDE = ALLOCATED (YD%RDIVDE)
WRITE (KLUN) LRDIVDE
IF (LRDIVDE) THEN
  WRITE (KLUN) LBOUND (YD%RDIVDE)
  WRITE (KLUN) UBOUND (YD%RDIVDE)
  WRITE (KLUN) YD%RDIVDE
ENDIF
LRDISPE = ALLOCATED (YD%RDISPE)
WRITE (KLUN) LRDISPE
IF (LRDISPE) THEN
  WRITE (KLUN) LBOUND (YD%RDISPE)
  WRITE (KLUN) UBOUND (YD%RDISPE)
  WRITE (KLUN) YD%RDISPE
ENDIF
LRDSVORE = ALLOCATED (YD%RDSVORE)
WRITE (KLUN) LRDSVORE
IF (LRDSVORE) THEN
  WRITE (KLUN) LBOUND (YD%RDSVORE)
  WRITE (KLUN) UBOUND (YD%RDSVORE)
  WRITE (KLUN) YD%RDSVORE
ENDIF
LRDSDIVE = ALLOCATED (YD%RDSDIVE)
WRITE (KLUN) LRDSDIVE
IF (LRDSDIVE) THEN
  WRITE (KLUN) LBOUND (YD%RDSDIVE)
  WRITE (KLUN) UBOUND (YD%RDSDIVE)
  WRITE (KLUN) YD%RDSDIVE
ENDIF
LRDSVDE = ALLOCATED (YD%RDSVDE)
WRITE (KLUN) LRDSVDE
IF (LRDSVDE) THEN
  WRITE (KLUN) LBOUND (YD%RDSVDE)
  WRITE (KLUN) UBOUND (YD%RDSVDE)
  WRITE (KLUN) YD%RDSVDE
ENDIF
LREFILV = ALLOCATED (YD%REFILV)
WRITE (KLUN) LREFILV
IF (LREFILV) THEN
  WRITE (KLUN) LBOUND (YD%REFILV)
  WRITE (KLUN) UBOUND (YD%REFILV)
  WRITE (KLUN) YD%REFILV
ENDIF
LREFILD = ALLOCATED (YD%REFILD)
WRITE (KLUN) LREFILD
IF (LREFILD) THEN
  WRITE (KLUN) LBOUND (YD%REFILD)
  WRITE (KLUN) UBOUND (YD%REFILD)
  WRITE (KLUN) YD%REFILD
ENDIF
WRITE (KLUN) YD%LESIDG
WRITE (KLUN) YD%RTHRESIDG
WRITE (KLUN) YD%XMALD
WRITE (KLUN) YD%TCDIS
END SUBROUTINE

SUBROUTINE LOAD_TEDYN (KLUN, YD)
USE PARKIND1, ONLY : JPRD

IMPLICIT NONE
INTEGER, INTENT (IN) :: KLUN
TYPE (TEDYN), INTENT (OUT), TARGET :: YD
INTEGER :: IL1(1), IU1(1), IL2(2), IU2(2), IL3(3), IU3(3)
LOGICAL :: LRDIDIVE, LRDIGFLE, LRDIPDE, LRDISPE, LRDITE, LRDIVDE, LRDIVORE, LRDSDIVE, LRDSVDE, LRDSVORE
LOGICAL :: LREFILD, LREFILV
REAL(KIND=JPRD) :: ZTMP0
REAL(KIND=JPRD), ALLOCATABLE :: ZTMP1 (:)
REAL(KIND=JPRD), ALLOCATABLE :: ZTMP2 (:,:)
REAL(KIND=JPRD), ALLOCATABLE :: ZTMP3 (:,:,:)
READ (KLUN) LRDIVORE
IF (LRDIVORE) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%RDIVORE (IL2(1):IU2(1), IL2(2):IU2(2)))
  ALLOCATE (ZTMP2(LBOUND(YD%RDIVORE,1):UBOUND(YD%RDIVORE,1), LBOUND(YD%RDIVORE,2):UBOUND(YD%RDIVORE,2)))
  READ (KLUN) ZTMP2
  YD%RDIVORE = ZTMP2
  DEALLOCATE (ZTMP2)
ENDIF
READ (KLUN) LRDIDIVE
IF (LRDIDIVE) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%RDIDIVE (IL2(1):IU2(1), IL2(2):IU2(2)))
  ALLOCATE (ZTMP2(LBOUND(YD%RDIDIVE,1):UBOUND(YD%RDIDIVE,1), LBOUND(YD%RDIDIVE,2):UBOUND(YD%RDIDIVE,2)))
  READ (KLUN) ZTMP2
  YD%RDIDIVE = ZTMP2
  DEALLOCATE (ZTMP2)
ENDIF
READ (KLUN) LRDITE
IF (LRDITE) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%RDITE (IL2(1):IU2(1), IL2(2):IU2(2)))
  ALLOCATE (ZTMP2(LBOUND(YD%RDITE,1):UBOUND(YD%RDITE,1), LBOUND(YD%RDITE,2):UBOUND(YD%RDITE,2)))
  READ (KLUN) ZTMP2
  YD%RDITE = ZTMP2
  DEALLOCATE (ZTMP2)
ENDIF
READ (KLUN) LRDIGFLE
IF (LRDIGFLE) THEN
  READ (KLUN) IL3
  READ (KLUN) IU3
  ALLOCATE (YD%RDIGFLE (IL3(1):IU3(1), IL3(2):IU3(2), IL3(3):IU3(3)))
  ALLOCATE (ZTMP3(LBOUND(YD%RDIGFLE,1):UBOUND(YD%RDIGFLE,1), LBOUND(YD%RDIGFLE,2):UBOUND(YD%RDIGFLE,2), LBOUND(YD%RDIGFLE,3):UBOUND(YD%RDIGFLE,3)))
  READ (KLUN) ZTMP3
  YD%RDIGFLE = ZTMP3
  DEALLOCATE (ZTMP3)
ENDIF
READ (KLUN) LRDIPDE
IF (LRDIPDE) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%RDIPDE (IL2(1):IU2(1), IL2(2):IU2(2)))
  ALLOCATE (ZTMP2(LBOUND(YD%RDIPDE,1):UBOUND(YD%RDIPDE,1), LBOUND(YD%RDIPDE,2):UBOUND(YD%RDIPDE,2)))
  READ (KLUN) ZTMP2
  YD%RDIPDE = ZTMP2
  DEALLOCATE (ZTMP2)
ENDIF
READ (KLUN) LRDIVDE
IF (LRDIVDE) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%RDIVDE (IL2(1):IU2(1), IL2(2):IU2(2)))
  ALLOCATE (ZTMP2(LBOUND(YD%RDIVDE,1):UBOUND(YD%RDIVDE,1), LBOUND(YD%RDIVDE,2):UBOUND(YD%RDIVDE,2)))
  READ (KLUN) ZTMP2
  YD%RDIVDE = ZTMP2
  DEALLOCATE (ZTMP2)
ENDIF
READ (KLUN) LRDISPE
IF (LRDISPE) THEN
  READ (KLUN) IL1
  READ (KLUN) IU1
  ALLOCATE (YD%RDISPE (IL1(1):IU1(1)))
  ALLOCATE (ZTMP1(LBOUND(YD%RDISPE,1):UBOUND(YD%RDISPE,1)))
  READ (KLUN) ZTMP1
  YD%RDISPE = ZTMP1
  DEALLOCATE (ZTMP1)
ENDIF
READ (KLUN) LRDSVORE
IF (LRDSVORE) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%RDSVORE (IL2(1):IU2(1), IL2(2):IU2(2)))
  ALLOCATE (ZTMP2(LBOUND(YD%RDSVORE,1):UBOUND(YD%RDSVORE,1), LBOUND(YD%RDSVORE,2):UBOUND(YD%RDSVORE,2)))
  READ (KLUN) ZTMP2
  YD%RDSVORE = ZTMP2
  DEALLOCATE (ZTMP2)
ENDIF
READ (KLUN) LRDSDIVE
IF (LRDSDIVE) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%RDSDIVE (IL2(1):IU2(1), IL2(2):IU2(2)))
  ALLOCATE (ZTMP2(LBOUND(YD%RDSDIVE,1):UBOUND(YD%RDSDIVE,1), LBOUND(YD%RDSDIVE,2):UBOUND(YD%RDSDIVE,2)))
  READ (KLUN) ZTMP2
  YD%RDSDIVE = ZTMP2
  DEALLOCATE (ZTMP2)
ENDIF
READ (KLUN) LRDSVDE
IF (LRDSVDE) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%RDSVDE (IL2(1):IU2(1), IL2(2):IU2(2)))
  ALLOCATE (ZTMP2(LBOUND(YD%RDSVDE,1):UBOUND(YD%RDSVDE,1), LBOUND(YD%RDSVDE,2):UBOUND(YD%RDSVDE,2)))
  READ (KLUN) ZTMP2
  YD%RDSVDE = ZTMP2
  DEALLOCATE (ZTMP2)
ENDIF
READ (KLUN) LREFILV
IF (LREFILV) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%REFILV (IL2(1):IU2(1), IL2(2):IU2(2)))
  ALLOCATE (ZTMP2(LBOUND(YD%REFILV,1):UBOUND(YD%REFILV,1), LBOUND(YD%REFILV,2):UBOUND(YD%REFILV,2)))
  READ (KLUN) ZTMP2
  YD%REFILV = ZTMP2
  DEALLOCATE (ZTMP2)
ENDIF
READ (KLUN) LREFILD
IF (LREFILD) THEN
  READ (KLUN) IL2
  READ (KLUN) IU2
  ALLOCATE (YD%REFILD (IL2(1):IU2(1), IL2(2):IU2(2)))
  ALLOCATE (ZTMP2(LBOUND(YD%REFILD,1):UBOUND(YD%REFILD,1), LBOUND(YD%REFILD,2):UBOUND(YD%REFILD,2)))
  READ (KLUN) ZTMP2
  YD%REFILD = ZTMP2
  DEALLOCATE (ZTMP2)
ENDIF
READ (KLUN) YD%LESIDG
READ (KLUN) ZTMP0
YD%RTHRESIDG = ZTMP0
READ (KLUN) ZTMP0
YD%XMALD = ZTMP0
READ (KLUN) ZTMP0
YD%TCDIS = ZTMP0
END SUBROUTINE


SUBROUTINE COPY_TEDYN (YD, LDCREATED, LDFIELDAPI)

IMPLICIT NONE
TYPE (TEDYN), INTENT (IN), TARGET :: YD
LOGICAL, OPTIONAL, INTENT (IN) :: LDCREATED, LDFIELDAPI
LOGICAL :: LLCREATED
LOGICAL :: LLFIELDAPI
LOGICAL :: LRDIDIVE, LRDIGFLE, LRDIPDE, LRDISPE, LRDITE, LRDIVDE, LRDIVORE, LRDSDIVE, LRDSVDE, LRDSVORE
LOGICAL :: LREFILD, LREFILV

LLFIELDAPI = .FALSE.
IF (PRESENT (LDFIELDAPI)) THEN
  LLFIELDAPI = LDFIELDAPI
ENDIF
LLCREATED = .FALSE.
IF (PRESENT (LDCREATED)) THEN
  LLCREATED = LDCREATED
ENDIF
IF (.NOT. LLCREATED) THEN
  !$ACC ENTER DATA CREATE (YD)
  !$ACC UPDATE DEVICE (YD)
ENDIF
LRDIVORE = ALLOCATED (YD%RDIVORE)
IF (LRDIVORE) THEN
  !$ACC ENTER DATA CREATE (YD%RDIVORE)
  !$ACC UPDATE DEVICE (YD%RDIVORE)
  !$ACC ENTER DATA ATTACH (YD%RDIVORE)
ENDIF

LRDIDIVE = ALLOCATED (YD%RDIDIVE)
IF (LRDIDIVE) THEN
  !$ACC ENTER DATA CREATE (YD%RDIDIVE)
  !$ACC UPDATE DEVICE (YD%RDIDIVE)
  !$ACC ENTER DATA ATTACH (YD%RDIDIVE)
ENDIF

LRDITE = ALLOCATED (YD%RDITE)
IF (LRDITE) THEN
  !$ACC ENTER DATA CREATE (YD%RDITE)
  !$ACC UPDATE DEVICE (YD%RDITE)
  !$ACC ENTER DATA ATTACH (YD%RDITE)
ENDIF

LRDIGFLE = ALLOCATED (YD%RDIGFLE)
IF (LRDIGFLE) THEN
  !$ACC ENTER DATA CREATE (YD%RDIGFLE)
  !$ACC UPDATE DEVICE (YD%RDIGFLE)
  !$ACC ENTER DATA ATTACH (YD%RDIGFLE)
ENDIF

LRDIPDE = ALLOCATED (YD%RDIPDE)
IF (LRDIPDE) THEN
  !$ACC ENTER DATA CREATE (YD%RDIPDE)
  !$ACC UPDATE DEVICE (YD%RDIPDE)
  !$ACC ENTER DATA ATTACH (YD%RDIPDE)
ENDIF

LRDIVDE = ALLOCATED (YD%RDIVDE)
IF (LRDIVDE) THEN
  !$ACC ENTER DATA CREATE (YD%RDIVDE)
  !$ACC UPDATE DEVICE (YD%RDIVDE)
  !$ACC ENTER DATA ATTACH (YD%RDIVDE)
ENDIF

LRDISPE = ALLOCATED (YD%RDISPE)
IF (LRDISPE) THEN
  !$ACC ENTER DATA CREATE (YD%RDISPE)
  !$ACC UPDATE DEVICE (YD%RDISPE)
  !$ACC ENTER DATA ATTACH (YD%RDISPE)
ENDIF

LRDSVORE = ALLOCATED (YD%RDSVORE)
IF (LRDSVORE) THEN
  !$ACC ENTER DATA CREATE (YD%RDSVORE)
  !$ACC UPDATE DEVICE (YD%RDSVORE)
  !$ACC ENTER DATA ATTACH (YD%RDSVORE)
ENDIF

LRDSDIVE = ALLOCATED (YD%RDSDIVE)
IF (LRDSDIVE) THEN
  !$ACC ENTER DATA CREATE (YD%RDSDIVE)
  !$ACC UPDATE DEVICE (YD%RDSDIVE)
  !$ACC ENTER DATA ATTACH (YD%RDSDIVE)
ENDIF

LRDSVDE = ALLOCATED (YD%RDSVDE)
IF (LRDSVDE) THEN
  !$ACC ENTER DATA CREATE (YD%RDSVDE)
  !$ACC UPDATE DEVICE (YD%RDSVDE)
  !$ACC ENTER DATA ATTACH (YD%RDSVDE)
ENDIF

LREFILV = ALLOCATED (YD%REFILV)
IF (LREFILV) THEN
  !$ACC ENTER DATA CREATE (YD%REFILV)
  !$ACC UPDATE DEVICE (YD%REFILV)
  !$ACC ENTER DATA ATTACH (YD%REFILV)
ENDIF

LREFILD = ALLOCATED (YD%REFILD)
IF (LREFILD) THEN
  !$ACC ENTER DATA CREATE (YD%REFILD)
  !$ACC UPDATE DEVICE (YD%REFILD)
  !$ACC ENTER DATA ATTACH (YD%REFILD)
ENDIF





END SUBROUTINE

SUBROUTINE HOST_TEDYN (YD)

IMPLICIT NONE
TYPE (TEDYN), TARGET :: YD
LOGICAL :: LRDIDIVE, LRDIGFLE, LRDIPDE, LRDISPE, LRDITE, LRDIVDE, LRDIVORE, LRDSDIVE, LRDSVDE, LRDSVORE
LOGICAL :: LREFILD, LREFILV
















END SUBROUTINE

     

SUBROUTINE CRC64_TEDYN (YD, KLUN, CDPATH)
USE CRC64_INTRINSIC, ONLY : FCRC64 => CRC64

IMPLICIT NONE
TYPE (TEDYN), TARGET :: YD
INTEGER, INTENT (IN) :: KLUN
CHARACTER(LEN=*), INTENT (IN) :: CDPATH
CHARACTER(LEN=128) :: CLIND
LOGICAL :: LRDIDIVE, LRDIGFLE, LRDIPDE, LRDISPE, LRDITE, LRDIVDE, LRDIVORE, LRDSDIVE, LRDSVDE, LRDSVORE
LOGICAL :: LREFILD, LREFILV
WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%RDIVORE), CDPATH//'%RDIVORE'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%RDIDIVE), CDPATH//'%RDIDIVE'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%RDITE), CDPATH//'%RDITE'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%RDIGFLE), CDPATH//'%RDIGFLE'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%RDIPDE), CDPATH//'%RDIPDE'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%RDIVDE), CDPATH//'%RDIVDE'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%RDISPE), CDPATH//'%RDISPE'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%RDSVORE), CDPATH//'%RDSVORE'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%RDSDIVE), CDPATH//'%RDSDIVE'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%RDSVDE), CDPATH//'%RDSVDE'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%REFILV), CDPATH//'%REFILV'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%REFILD), CDPATH//'%REFILD'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%LESIDG), CDPATH//'%LESIDG'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%RTHRESIDG), CDPATH//'%RTHRESIDG'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%XMALD), CDPATH//'%XMALD'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%TCDIS), CDPATH//'%TCDIS'

END SUBROUTINE

SUBROUTINE WIPE_TEDYN (YD, LDDELETED, LDFIELDAPI)

IMPLICIT NONE
TYPE (TEDYN), INTENT (IN), TARGET :: YD
LOGICAL, OPTIONAL, INTENT (IN) :: LDDELETED, LDFIELDAPI
LOGICAL :: LLDELETED
LOGICAL :: LLFIELDAPI
LOGICAL :: LRDIDIVE, LRDIGFLE, LRDIPDE, LRDISPE, LRDITE, LRDIVDE, LRDIVORE, LRDSDIVE, LRDSVDE, LRDSVORE
LOGICAL :: LREFILD, LREFILV

LLFIELDAPI = .FALSE.
IF (PRESENT (LDFIELDAPI)) THEN
  LLFIELDAPI = LDFIELDAPI
ENDIF
LRDIVORE = ALLOCATED (YD%RDIVORE)
IF (LRDIVORE) THEN
  !$ACC EXIT DATA DETACH (YD%RDIVORE)
  !$ACC EXIT DATA DETACH (YD%RDIVORE)
ENDIF

LRDIDIVE = ALLOCATED (YD%RDIDIVE)
IF (LRDIDIVE) THEN
  !$ACC EXIT DATA DETACH (YD%RDIDIVE)
  !$ACC EXIT DATA DETACH (YD%RDIDIVE)
ENDIF

LRDITE = ALLOCATED (YD%RDITE)
IF (LRDITE) THEN
  !$ACC EXIT DATA DETACH (YD%RDITE)
  !$ACC EXIT DATA DETACH (YD%RDITE)
ENDIF

LRDIGFLE = ALLOCATED (YD%RDIGFLE)
IF (LRDIGFLE) THEN
  !$ACC EXIT DATA DETACH (YD%RDIGFLE)
  !$ACC EXIT DATA DETACH (YD%RDIGFLE)
ENDIF

LRDIPDE = ALLOCATED (YD%RDIPDE)
IF (LRDIPDE) THEN
  !$ACC EXIT DATA DETACH (YD%RDIPDE)
  !$ACC EXIT DATA DETACH (YD%RDIPDE)
ENDIF

LRDIVDE = ALLOCATED (YD%RDIVDE)
IF (LRDIVDE) THEN
  !$ACC EXIT DATA DETACH (YD%RDIVDE)
  !$ACC EXIT DATA DETACH (YD%RDIVDE)
ENDIF

LRDISPE = ALLOCATED (YD%RDISPE)
IF (LRDISPE) THEN
  !$ACC EXIT DATA DETACH (YD%RDISPE)
  !$ACC EXIT DATA DETACH (YD%RDISPE)
ENDIF

LRDSVORE = ALLOCATED (YD%RDSVORE)
IF (LRDSVORE) THEN
  !$ACC EXIT DATA DETACH (YD%RDSVORE)
  !$ACC EXIT DATA DETACH (YD%RDSVORE)
ENDIF

LRDSDIVE = ALLOCATED (YD%RDSDIVE)
IF (LRDSDIVE) THEN
  !$ACC EXIT DATA DETACH (YD%RDSDIVE)
  !$ACC EXIT DATA DETACH (YD%RDSDIVE)
ENDIF

LRDSVDE = ALLOCATED (YD%RDSVDE)
IF (LRDSVDE) THEN
  !$ACC EXIT DATA DETACH (YD%RDSVDE)
  !$ACC EXIT DATA DETACH (YD%RDSVDE)
ENDIF

LREFILV = ALLOCATED (YD%REFILV)
IF (LREFILV) THEN
  !$ACC EXIT DATA DETACH (YD%REFILV)
  !$ACC EXIT DATA DETACH (YD%REFILV)
ENDIF

LREFILD = ALLOCATED (YD%REFILD)
IF (LREFILD) THEN
  !$ACC EXIT DATA DETACH (YD%REFILD)
  !$ACC EXIT DATA DETACH (YD%REFILD)
ENDIF





LLDELETED = .FALSE.
IF (PRESENT (LDDELETED)) THEN
  LLDELETED = LDDELETED
ENDIF
IF (.NOT. LLDELETED) THEN
  !$ACC EXIT DATA DELETE (YD)
ENDIF
END SUBROUTINE

INTEGER*8 FUNCTION SIZE_TEDYN (YD, CDPATH, LDPRINT) RESULT (KSIZE)

IMPLICIT NONE
TYPE (TEDYN),     INTENT (IN), TARGET :: YD
CHARACTER(LEN=*), INTENT (IN), OPTIONAL :: CDPATH
LOGICAL,          INTENT (IN), OPTIONAL :: LDPRINT
INTEGER*8 :: ISIZE, JSIZE
LOGICAL :: LLPRINT
CHARACTER(LEN=128) :: CLPATH
LOGICAL :: LRDIDIVE, LRDIGFLE, LRDIPDE, LRDISPE, LRDITE, LRDIVDE, LRDIVORE, LRDSDIVE, LRDSVDE, LRDSVORE
LOGICAL :: LREFILD, LREFILV

LLPRINT = .FALSE.
IF (PRESENT (LDPRINT)) THEN
  LLPRINT = LDPRINT
ENDIF
CLPATH=''
IF (PRESENT (CDPATH)) THEN
  CLPATH = CDPATH
ENDIF
KSIZE = 0
LRDIVORE = ALLOCATED (YD%RDIVORE)
IF (LRDIVORE) THEN
  ISIZE = KIND (YD%RDIVORE) * SIZE (YD%RDIVORE)
  IF (LLPRINT) THEN
    WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
    WRITE (*, *) TRIM (CLPATH)//'%RDIVORE'
  ENDIF
  KSIZE = KSIZE + ISIZE
ENDIF
LRDIDIVE = ALLOCATED (YD%RDIDIVE)
IF (LRDIDIVE) THEN
  ISIZE = KIND (YD%RDIDIVE) * SIZE (YD%RDIDIVE)
  IF (LLPRINT) THEN
    WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
    WRITE (*, *) TRIM (CLPATH)//'%RDIDIVE'
  ENDIF
  KSIZE = KSIZE + ISIZE
ENDIF
LRDITE = ALLOCATED (YD%RDITE)
IF (LRDITE) THEN
  ISIZE = KIND (YD%RDITE) * SIZE (YD%RDITE)
  IF (LLPRINT) THEN
    WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
    WRITE (*, *) TRIM (CLPATH)//'%RDITE'
  ENDIF
  KSIZE = KSIZE + ISIZE
ENDIF
LRDIGFLE = ALLOCATED (YD%RDIGFLE)
IF (LRDIGFLE) THEN
  ISIZE = KIND (YD%RDIGFLE) * SIZE (YD%RDIGFLE)
  IF (LLPRINT) THEN
    WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
    WRITE (*, *) TRIM (CLPATH)//'%RDIGFLE'
  ENDIF
  KSIZE = KSIZE + ISIZE
ENDIF
LRDIPDE = ALLOCATED (YD%RDIPDE)
IF (LRDIPDE) THEN
  ISIZE = KIND (YD%RDIPDE) * SIZE (YD%RDIPDE)
  IF (LLPRINT) THEN
    WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
    WRITE (*, *) TRIM (CLPATH)//'%RDIPDE'
  ENDIF
  KSIZE = KSIZE + ISIZE
ENDIF
LRDIVDE = ALLOCATED (YD%RDIVDE)
IF (LRDIVDE) THEN
  ISIZE = KIND (YD%RDIVDE) * SIZE (YD%RDIVDE)
  IF (LLPRINT) THEN
    WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
    WRITE (*, *) TRIM (CLPATH)//'%RDIVDE'
  ENDIF
  KSIZE = KSIZE + ISIZE
ENDIF
LRDISPE = ALLOCATED (YD%RDISPE)
IF (LRDISPE) THEN
  ISIZE = KIND (YD%RDISPE) * SIZE (YD%RDISPE)
  IF (LLPRINT) THEN
    WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
    WRITE (*, *) TRIM (CLPATH)//'%RDISPE'
  ENDIF
  KSIZE = KSIZE + ISIZE
ENDIF
LRDSVORE = ALLOCATED (YD%RDSVORE)
IF (LRDSVORE) THEN
  ISIZE = KIND (YD%RDSVORE) * SIZE (YD%RDSVORE)
  IF (LLPRINT) THEN
    WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
    WRITE (*, *) TRIM (CLPATH)//'%RDSVORE'
  ENDIF
  KSIZE = KSIZE + ISIZE
ENDIF
LRDSDIVE = ALLOCATED (YD%RDSDIVE)
IF (LRDSDIVE) THEN
  ISIZE = KIND (YD%RDSDIVE) * SIZE (YD%RDSDIVE)
  IF (LLPRINT) THEN
    WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
    WRITE (*, *) TRIM (CLPATH)//'%RDSDIVE'
  ENDIF
  KSIZE = KSIZE + ISIZE
ENDIF
LRDSVDE = ALLOCATED (YD%RDSVDE)
IF (LRDSVDE) THEN
  ISIZE = KIND (YD%RDSVDE) * SIZE (YD%RDSVDE)
  IF (LLPRINT) THEN
    WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
    WRITE (*, *) TRIM (CLPATH)//'%RDSVDE'
  ENDIF
  KSIZE = KSIZE + ISIZE
ENDIF
LREFILV = ALLOCATED (YD%REFILV)
IF (LREFILV) THEN
  ISIZE = KIND (YD%REFILV) * SIZE (YD%REFILV)
  IF (LLPRINT) THEN
    WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
    WRITE (*, *) TRIM (CLPATH)//'%REFILV'
  ENDIF
  KSIZE = KSIZE + ISIZE
ENDIF
LREFILD = ALLOCATED (YD%REFILD)
IF (LREFILD) THEN
  ISIZE = KIND (YD%REFILD) * SIZE (YD%REFILD)
  IF (LLPRINT) THEN
    WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
    WRITE (*, *) TRIM (CLPATH)//'%REFILD'
  ENDIF
  KSIZE = KSIZE + ISIZE
ENDIF
ISIZE = KIND (YD%LESIDG)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%LESIDG'
ENDIF
KSIZE = KSIZE + ISIZE
ISIZE = KIND (YD%RTHRESIDG)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%RTHRESIDG'
ENDIF
KSIZE = KSIZE + ISIZE
ISIZE = KIND (YD%XMALD)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%XMALD'
ENDIF
KSIZE = KSIZE + ISIZE
ISIZE = KIND (YD%TCDIS)
IF (LLPRINT) THEN
  WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
  WRITE (*, *) TRIM (CLPATH)//'%TCDIS'
ENDIF
KSIZE = KSIZE + ISIZE
END FUNCTION

END MODULE
