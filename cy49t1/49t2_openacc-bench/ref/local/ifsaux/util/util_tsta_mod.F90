MODULE UTIL_TSTA_MOD

USE YOMSTA, ONLY : TSTA

INTERFACE SAVE
MODULE PROCEDURE SAVE_TSTA
END INTERFACE

INTERFACE LOAD
MODULE PROCEDURE LOAD_TSTA
END INTERFACE

INTERFACE COPY
MODULE PROCEDURE COPY_TSTA
END INTERFACE

INTERFACE HOST
MODULE PROCEDURE HOST_TSTA
END INTERFACE

     
INTERFACE CRC64
MODULE PROCEDURE CRC64_TSTA
END INTERFACE

INTERFACE WIPE
MODULE PROCEDURE WIPE_TSTA
END INTERFACE

INTERFACE SIZE
MODULE PROCEDURE SIZE_TSTA
END INTERFACE


CONTAINS

SUBROUTINE SAVE_TSTA (KLUN, YD)

IMPLICIT NONE
INTEGER, INTENT (IN) :: KLUN
TYPE (TSTA), INTENT (IN), TARGET :: YD
LOGICAL :: LSTDEN, LSTPHI, LSTPRE, LSTPREH, LSTTEM, LSTZ, LSVETAF, LSVETAH
LSTPREH = ALLOCATED (YD%STPREH)
WRITE (KLUN) LSTPREH
IF (LSTPREH) THEN
  WRITE (KLUN) LBOUND (YD%STPREH)
  WRITE (KLUN) UBOUND (YD%STPREH)
  WRITE (KLUN) YD%STPREH
ENDIF
LSTPRE = ALLOCATED (YD%STPRE)
WRITE (KLUN) LSTPRE
IF (LSTPRE) THEN
  WRITE (KLUN) LBOUND (YD%STPRE)
  WRITE (KLUN) UBOUND (YD%STPRE)
  WRITE (KLUN) YD%STPRE
ENDIF
LSTPHI = ALLOCATED (YD%STPHI)
WRITE (KLUN) LSTPHI
IF (LSTPHI) THEN
  WRITE (KLUN) LBOUND (YD%STPHI)
  WRITE (KLUN) UBOUND (YD%STPHI)
  WRITE (KLUN) YD%STPHI
ENDIF
LSTTEM = ALLOCATED (YD%STTEM)
WRITE (KLUN) LSTTEM
IF (LSTTEM) THEN
  WRITE (KLUN) LBOUND (YD%STTEM)
  WRITE (KLUN) UBOUND (YD%STTEM)
  WRITE (KLUN) YD%STTEM
ENDIF
LSTDEN = ALLOCATED (YD%STDEN)
WRITE (KLUN) LSTDEN
IF (LSTDEN) THEN
  WRITE (KLUN) LBOUND (YD%STDEN)
  WRITE (KLUN) UBOUND (YD%STDEN)
  WRITE (KLUN) YD%STDEN
ENDIF
LSTZ = ALLOCATED (YD%STZ)
WRITE (KLUN) LSTZ
IF (LSTZ) THEN
  WRITE (KLUN) LBOUND (YD%STZ)
  WRITE (KLUN) UBOUND (YD%STZ)
  WRITE (KLUN) YD%STZ
ENDIF
LSVETAH = ALLOCATED (YD%SVETAH)
WRITE (KLUN) LSVETAH
IF (LSVETAH) THEN
  WRITE (KLUN) LBOUND (YD%SVETAH)
  WRITE (KLUN) UBOUND (YD%SVETAH)
  WRITE (KLUN) YD%SVETAH
ENDIF
LSVETAF = ALLOCATED (YD%SVETAF)
WRITE (KLUN) LSVETAF
IF (LSVETAF) THEN
  WRITE (KLUN) LBOUND (YD%SVETAF)
  WRITE (KLUN) UBOUND (YD%SVETAF)
  WRITE (KLUN) YD%SVETAF
ENDIF
END SUBROUTINE

SUBROUTINE LOAD_TSTA (KLUN, YD)
USE PARKIND1, ONLY : JPRD

IMPLICIT NONE
INTEGER, INTENT (IN) :: KLUN
TYPE (TSTA), INTENT (OUT), TARGET :: YD
INTEGER :: IL1(1), IU1(1)
LOGICAL :: LSTDEN, LSTPHI, LSTPRE, LSTPREH, LSTTEM, LSTZ, LSVETAF, LSVETAH
REAL(KIND=JPRD), ALLOCATABLE :: ZTMP1 (:)
READ (KLUN) LSTPREH
IF (LSTPREH) THEN
  READ (KLUN) IL1
  READ (KLUN) IU1
  ALLOCATE (YD%STPREH (IL1(1):IU1(1)))
  ALLOCATE (ZTMP1(LBOUND(YD%STPREH,1):UBOUND(YD%STPREH,1)))
  READ (KLUN) ZTMP1
  YD%STPREH = ZTMP1
  DEALLOCATE (ZTMP1)
ENDIF
READ (KLUN) LSTPRE
IF (LSTPRE) THEN
  READ (KLUN) IL1
  READ (KLUN) IU1
  ALLOCATE (YD%STPRE (IL1(1):IU1(1)))
  ALLOCATE (ZTMP1(LBOUND(YD%STPRE,1):UBOUND(YD%STPRE,1)))
  READ (KLUN) ZTMP1
  YD%STPRE = ZTMP1
  DEALLOCATE (ZTMP1)
ENDIF
READ (KLUN) LSTPHI
IF (LSTPHI) THEN
  READ (KLUN) IL1
  READ (KLUN) IU1
  ALLOCATE (YD%STPHI (IL1(1):IU1(1)))
  ALLOCATE (ZTMP1(LBOUND(YD%STPHI,1):UBOUND(YD%STPHI,1)))
  READ (KLUN) ZTMP1
  YD%STPHI = ZTMP1
  DEALLOCATE (ZTMP1)
ENDIF
READ (KLUN) LSTTEM
IF (LSTTEM) THEN
  READ (KLUN) IL1
  READ (KLUN) IU1
  ALLOCATE (YD%STTEM (IL1(1):IU1(1)))
  ALLOCATE (ZTMP1(LBOUND(YD%STTEM,1):UBOUND(YD%STTEM,1)))
  READ (KLUN) ZTMP1
  YD%STTEM = ZTMP1
  DEALLOCATE (ZTMP1)
ENDIF
READ (KLUN) LSTDEN
IF (LSTDEN) THEN
  READ (KLUN) IL1
  READ (KLUN) IU1
  ALLOCATE (YD%STDEN (IL1(1):IU1(1)))
  ALLOCATE (ZTMP1(LBOUND(YD%STDEN,1):UBOUND(YD%STDEN,1)))
  READ (KLUN) ZTMP1
  YD%STDEN = ZTMP1
  DEALLOCATE (ZTMP1)
ENDIF
READ (KLUN) LSTZ
IF (LSTZ) THEN
  READ (KLUN) IL1
  READ (KLUN) IU1
  ALLOCATE (YD%STZ (IL1(1):IU1(1)))
  ALLOCATE (ZTMP1(LBOUND(YD%STZ,1):UBOUND(YD%STZ,1)))
  READ (KLUN) ZTMP1
  YD%STZ = ZTMP1
  DEALLOCATE (ZTMP1)
ENDIF
READ (KLUN) LSVETAH
IF (LSVETAH) THEN
  READ (KLUN) IL1
  READ (KLUN) IU1
  ALLOCATE (YD%SVETAH (IL1(1):IU1(1)))
  ALLOCATE (ZTMP1(LBOUND(YD%SVETAH,1):UBOUND(YD%SVETAH,1)))
  READ (KLUN) ZTMP1
  YD%SVETAH = ZTMP1
  DEALLOCATE (ZTMP1)
ENDIF
READ (KLUN) LSVETAF
IF (LSVETAF) THEN
  READ (KLUN) IL1
  READ (KLUN) IU1
  ALLOCATE (YD%SVETAF (IL1(1):IU1(1)))
  ALLOCATE (ZTMP1(LBOUND(YD%SVETAF,1):UBOUND(YD%SVETAF,1)))
  READ (KLUN) ZTMP1
  YD%SVETAF = ZTMP1
  DEALLOCATE (ZTMP1)
ENDIF
END SUBROUTINE


SUBROUTINE COPY_TSTA (YD, LDCREATED, LDFIELDAPI)

IMPLICIT NONE
TYPE (TSTA), INTENT (IN), TARGET :: YD
LOGICAL, OPTIONAL, INTENT (IN) :: LDCREATED, LDFIELDAPI
LOGICAL :: LLCREATED
LOGICAL :: LLFIELDAPI
LOGICAL :: LSTDEN, LSTPHI, LSTPRE, LSTPREH, LSTTEM, LSTZ, LSVETAF, LSVETAH

LLFIELDAPI = .FALSE.
IF (PRESENT (LDFIELDAPI)) THEN
  LLFIELDAPI = LDFIELDAPI
ENDIF
LLCREATED = .FALSE.
IF (PRESENT (LDCREATED)) THEN
  LLCREATED = LDCREATED
ENDIF
IF (.NOT. LLCREATED) THEN
  !$ACC ENTER DATA CREATE (YD)
  !$ACC UPDATE DEVICE (YD)
ENDIF
LSTPREH = ALLOCATED (YD%STPREH)
IF (LSTPREH) THEN
  !$ACC ENTER DATA CREATE (YD%STPREH)
  !$ACC UPDATE DEVICE (YD%STPREH)
  !$ACC ENTER DATA ATTACH (YD%STPREH)
ENDIF

LSTPRE = ALLOCATED (YD%STPRE)
IF (LSTPRE) THEN
  !$ACC ENTER DATA CREATE (YD%STPRE)
  !$ACC UPDATE DEVICE (YD%STPRE)
  !$ACC ENTER DATA ATTACH (YD%STPRE)
ENDIF

LSTPHI = ALLOCATED (YD%STPHI)
IF (LSTPHI) THEN
  !$ACC ENTER DATA CREATE (YD%STPHI)
  !$ACC UPDATE DEVICE (YD%STPHI)
  !$ACC ENTER DATA ATTACH (YD%STPHI)
ENDIF

LSTTEM = ALLOCATED (YD%STTEM)
IF (LSTTEM) THEN
  !$ACC ENTER DATA CREATE (YD%STTEM)
  !$ACC UPDATE DEVICE (YD%STTEM)
  !$ACC ENTER DATA ATTACH (YD%STTEM)
ENDIF

LSTDEN = ALLOCATED (YD%STDEN)
IF (LSTDEN) THEN
  !$ACC ENTER DATA CREATE (YD%STDEN)
  !$ACC UPDATE DEVICE (YD%STDEN)
  !$ACC ENTER DATA ATTACH (YD%STDEN)
ENDIF

LSTZ = ALLOCATED (YD%STZ)
IF (LSTZ) THEN
  !$ACC ENTER DATA CREATE (YD%STZ)
  !$ACC UPDATE DEVICE (YD%STZ)
  !$ACC ENTER DATA ATTACH (YD%STZ)
ENDIF

LSVETAH = ALLOCATED (YD%SVETAH)
IF (LSVETAH) THEN
  !$ACC ENTER DATA CREATE (YD%SVETAH)
  !$ACC UPDATE DEVICE (YD%SVETAH)
  !$ACC ENTER DATA ATTACH (YD%SVETAH)
ENDIF

LSVETAF = ALLOCATED (YD%SVETAF)
IF (LSVETAF) THEN
  !$ACC ENTER DATA CREATE (YD%SVETAF)
  !$ACC UPDATE DEVICE (YD%SVETAF)
  !$ACC ENTER DATA ATTACH (YD%SVETAF)
ENDIF

END SUBROUTINE

SUBROUTINE HOST_TSTA (YD)

IMPLICIT NONE
TYPE (TSTA), TARGET :: YD
LOGICAL :: LSTDEN, LSTPHI, LSTPRE, LSTPREH, LSTTEM, LSTZ, LSVETAF, LSVETAH








END SUBROUTINE

     

SUBROUTINE CRC64_TSTA (YD, KLUN, CDPATH)
USE CRC64_INTRINSIC, ONLY : FCRC64 => CRC64

IMPLICIT NONE
TYPE (TSTA), TARGET :: YD
INTEGER, INTENT (IN) :: KLUN
CHARACTER(LEN=*), INTENT (IN) :: CDPATH
CHARACTER(LEN=128) :: CLIND
LOGICAL :: LSTDEN, LSTPHI, LSTPRE, LSTPREH, LSTTEM, LSTZ, LSVETAF, LSVETAH
WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%STPREH), CDPATH//'%STPREH'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%STPRE), CDPATH//'%STPRE'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%STPHI), CDPATH//'%STPHI'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%STTEM), CDPATH//'%STTEM'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%STDEN), CDPATH//'%STDEN'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%STZ), CDPATH//'%STZ'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%SVETAH), CDPATH//'%SVETAH'

WRITE (KLUN, '(Z16.16," ",A)') FCRC64 (YD%SVETAF), CDPATH//'%SVETAF'

END SUBROUTINE

SUBROUTINE WIPE_TSTA (YD, LDDELETED, LDFIELDAPI)

IMPLICIT NONE
TYPE (TSTA), INTENT (IN), TARGET :: YD
LOGICAL, OPTIONAL, INTENT (IN) :: LDDELETED, LDFIELDAPI
LOGICAL :: LLDELETED
LOGICAL :: LLFIELDAPI
LOGICAL :: LSTDEN, LSTPHI, LSTPRE, LSTPREH, LSTTEM, LSTZ, LSVETAF, LSVETAH

LLFIELDAPI = .FALSE.
IF (PRESENT (LDFIELDAPI)) THEN
  LLFIELDAPI = LDFIELDAPI
ENDIF
LSTPREH = ALLOCATED (YD%STPREH)
IF (LSTPREH) THEN
  !$ACC EXIT DATA DETACH (YD%STPREH)
  !$ACC EXIT DATA DETACH (YD%STPREH)
ENDIF

LSTPRE = ALLOCATED (YD%STPRE)
IF (LSTPRE) THEN
  !$ACC EXIT DATA DETACH (YD%STPRE)
  !$ACC EXIT DATA DETACH (YD%STPRE)
ENDIF

LSTPHI = ALLOCATED (YD%STPHI)
IF (LSTPHI) THEN
  !$ACC EXIT DATA DETACH (YD%STPHI)
  !$ACC EXIT DATA DETACH (YD%STPHI)
ENDIF

LSTTEM = ALLOCATED (YD%STTEM)
IF (LSTTEM) THEN
  !$ACC EXIT DATA DETACH (YD%STTEM)
  !$ACC EXIT DATA DETACH (YD%STTEM)
ENDIF

LSTDEN = ALLOCATED (YD%STDEN)
IF (LSTDEN) THEN
  !$ACC EXIT DATA DETACH (YD%STDEN)
  !$ACC EXIT DATA DETACH (YD%STDEN)
ENDIF

LSTZ = ALLOCATED (YD%STZ)
IF (LSTZ) THEN
  !$ACC EXIT DATA DETACH (YD%STZ)
  !$ACC EXIT DATA DETACH (YD%STZ)
ENDIF

LSVETAH = ALLOCATED (YD%SVETAH)
IF (LSVETAH) THEN
  !$ACC EXIT DATA DETACH (YD%SVETAH)
  !$ACC EXIT DATA DETACH (YD%SVETAH)
ENDIF

LSVETAF = ALLOCATED (YD%SVETAF)
IF (LSVETAF) THEN
  !$ACC EXIT DATA DETACH (YD%SVETAF)
  !$ACC EXIT DATA DETACH (YD%SVETAF)
ENDIF

LLDELETED = .FALSE.
IF (PRESENT (LDDELETED)) THEN
  LLDELETED = LDDELETED
ENDIF
IF (.NOT. LLDELETED) THEN
  !$ACC EXIT DATA DELETE (YD)
ENDIF
END SUBROUTINE

INTEGER*8 FUNCTION SIZE_TSTA (YD, CDPATH, LDPRINT) RESULT (KSIZE)

IMPLICIT NONE
TYPE (TSTA),     INTENT (IN), TARGET :: YD
CHARACTER(LEN=*), INTENT (IN), OPTIONAL :: CDPATH
LOGICAL,          INTENT (IN), OPTIONAL :: LDPRINT
INTEGER*8 :: ISIZE, JSIZE
LOGICAL :: LLPRINT
CHARACTER(LEN=128) :: CLPATH
LOGICAL :: LSTDEN, LSTPHI, LSTPRE, LSTPREH, LSTTEM, LSTZ, LSVETAF, LSVETAH

LLPRINT = .FALSE.
IF (PRESENT (LDPRINT)) THEN
  LLPRINT = LDPRINT
ENDIF
CLPATH=''
IF (PRESENT (CDPATH)) THEN
  CLPATH = CDPATH
ENDIF
KSIZE = 0
LSTPREH = ALLOCATED (YD%STPREH)
IF (LSTPREH) THEN
  ISIZE = KIND (YD%STPREH) * SIZE (YD%STPREH)
  IF (LLPRINT) THEN
    WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
    WRITE (*, *) TRIM (CLPATH)//'%STPREH'
  ENDIF
  KSIZE = KSIZE + ISIZE
ENDIF
LSTPRE = ALLOCATED (YD%STPRE)
IF (LSTPRE) THEN
  ISIZE = KIND (YD%STPRE) * SIZE (YD%STPRE)
  IF (LLPRINT) THEN
    WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
    WRITE (*, *) TRIM (CLPATH)//'%STPRE'
  ENDIF
  KSIZE = KSIZE + ISIZE
ENDIF
LSTPHI = ALLOCATED (YD%STPHI)
IF (LSTPHI) THEN
  ISIZE = KIND (YD%STPHI) * SIZE (YD%STPHI)
  IF (LLPRINT) THEN
    WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
    WRITE (*, *) TRIM (CLPATH)//'%STPHI'
  ENDIF
  KSIZE = KSIZE + ISIZE
ENDIF
LSTTEM = ALLOCATED (YD%STTEM)
IF (LSTTEM) THEN
  ISIZE = KIND (YD%STTEM) * SIZE (YD%STTEM)
  IF (LLPRINT) THEN
    WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
    WRITE (*, *) TRIM (CLPATH)//'%STTEM'
  ENDIF
  KSIZE = KSIZE + ISIZE
ENDIF
LSTDEN = ALLOCATED (YD%STDEN)
IF (LSTDEN) THEN
  ISIZE = KIND (YD%STDEN) * SIZE (YD%STDEN)
  IF (LLPRINT) THEN
    WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
    WRITE (*, *) TRIM (CLPATH)//'%STDEN'
  ENDIF
  KSIZE = KSIZE + ISIZE
ENDIF
LSTZ = ALLOCATED (YD%STZ)
IF (LSTZ) THEN
  ISIZE = KIND (YD%STZ) * SIZE (YD%STZ)
  IF (LLPRINT) THEN
    WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
    WRITE (*, *) TRIM (CLPATH)//'%STZ'
  ENDIF
  KSIZE = KSIZE + ISIZE
ENDIF
LSVETAH = ALLOCATED (YD%SVETAH)
IF (LSVETAH) THEN
  ISIZE = KIND (YD%SVETAH) * SIZE (YD%SVETAH)
  IF (LLPRINT) THEN
    WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
    WRITE (*, *) TRIM (CLPATH)//'%SVETAH'
  ENDIF
  KSIZE = KSIZE + ISIZE
ENDIF
LSVETAF = ALLOCATED (YD%SVETAF)
IF (LSVETAF) THEN
  ISIZE = KIND (YD%SVETAF) * SIZE (YD%SVETAF)
  IF (LLPRINT) THEN
    WRITE (*, '(I10," ")', ADVANCE='NO') ISIZE
    WRITE (*, *) TRIM (CLPATH)//'%SVETAF'
  ENDIF
  KSIZE = KSIZE + ISIZE
ENDIF
END FUNCTION

END MODULE
