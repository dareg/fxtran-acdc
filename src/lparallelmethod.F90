LOGICAL FUNCTION LPARALLELMETHOD (CDMETHOD, CDNAME) 

IMPLICIT NONE

CHARACTER (LEN=*),   INTENT (IN) :: CDMETHOD
CHARACTER (LEN=*),   INTENT (IN) :: CDNAME


CHARACTER (LEN=*), PARAMETER :: CLFILE = 'lparallelmethod.txt'
CHARACTER (LEN=256) :: CLMETHOD1, CLMETHOD2
CHARACTER (LEN=256) :: CLMETHOD

CHARACTER (LEN=256), ALLOCATABLE, SAVE :: CLNAMES (:)
CHARACTER (LEN=256), ALLOCATABLE, SAVE :: CLMETHODS (:)
INTEGER, ALLOCATABLE, SAVE :: ILNAMES (:)
LOGICAL, SAVE :: LLVERBOSE = .FALSE.
LOGICAL, SAVE :: LLINIT = .FALSE.

INTEGER :: ICOUNT, IERR, I
INTEGER, SAVE :: IDX = -1
INTEGER :: ILNAME
CHARACTER (LEN=16) :: CLENV

IF (.NOT. LLINIT) THEN

  CALL COUNTLINES (ICOUNT, CLFILE, IERR)
  CALL GETENV ('LPARALLELMETHOD_VERBOSE', CLENV)
  LLVERBOSE = TRIM (CLENV) /= '' .AND. TRIM (CLENV) /= '0'

  IF (IERR == 0) THEN

    ALLOCATE (CLNAMES (ICOUNT), CLMETHODS (ICOUNT), ILNAMES (ICOUNT))
    OPEN (77, FILE=CLFILE, FORM='FORMATTED')
    DO I = 1, ICOUNT
      READ (77, *) CLMETHODS (I), CLNAMES (I)
      ILNAMES (I) = LEN_TRIM (CLNAMES (I))
    ENDDO
    CLOSE (77)

    IF (LLVERBOSE) THEN
      WRITE (0, *) "------ "//TRIM (CLFILE)//" ------"
      DO I = 1, SIZE (CLNAMES)
        WRITE (0, '(A32," ",A)') CLMETHODS (I), TRIM (CLNAMES (I))
      ENDDO
      WRITE (0, *) "------ "//TRIM (CLFILE)//" ------"
    ENDIF

  ENDIF

  LLINIT = .TRUE.

ENDIF

CALL UPPER_CASE (CLMETHOD1, CDMETHOD)


ILNAME = LEN_TRIM (CDNAME)

IF (ALLOCATED (CLNAMES)) THEN
  

  ! Try previous match first

  IF ((1 <= IDX) .AND. (IDX <= SIZE (CLNAMES))) THEN
    IF (CLMETHODS (IDX)(1:1) /= '#') THEN
      IF (EQUAL (CDNAME, ILNAME, CLNAMES (IDX), ILNAMES (IDX))) THEN
        CALL UPPER_CASE (CLMETHOD2, CLMETHODS (IDX))
        LPARALLELMETHOD = TRIM (CLMETHOD1) == TRIM (CLMETHOD2)
        GOTO 999
      ENDIF
    ENDIF
  ENDIF

  
  IDX = -1

  DO I = 1, SIZE (CLNAMES)
    IF (CLMETHODS (I)(1:1) /= '#') THEN
      IF (EQUAL (CDNAME, ILNAME, CLNAMES (I), ILNAMES (I))) THEN
        CALL UPPER_CASE (CLMETHOD2, CLMETHODS (I))
        LPARALLELMETHOD = TRIM (CLMETHOD1) == TRIM (CLMETHOD2)
        IDX = I
        GOTO 999
      ENDIF
    ENDIF
  ENDDO
ENDIF

LPARALLELMETHOD = (CLMETHOD1 == "OPENMP") .OR. (CLMETHOD1 == "OPENMPMETHOD")

999 CONTINUE

IF (LLVERBOSE .AND. LPARALLELMETHOD) THEN
  IF (IDX > 0) THEN
    WRITE (0, '(A32," ",A)') CLMETHODS (I), TRIM (CLNAMES (I))
  ELSE
    WRITE (0, '(A32," ",A)') CLMETHOD1, TRIM (CDNAME)
    CALL FLUSH(0)
  ENDIF
ENDIF

CONTAINS

LOGICAL FUNCTION EQUAL (CDSTR1, KLEN1, CDSTR2, KLEN2)

CHARACTER (LEN=*) :: CDSTR1, CDSTR2
INTEGER :: KLEN1, KLEN2

INTEGER :: IC
CHARACTER :: C1, C2
INTEGER*1 :: IC1, IC2

EQUAL = .TRUE.

IF (KLEN1 /= KLEN2) THEN
  EQUAL = .FALSE.
  RETURN
ENDIF

DO IC = 1, KLEN1
  C1 = CDSTR1 (IC:IC)
  C2 = CDSTR2 (IC:IC)

  IC1 = ICHAR (C1)
  IC2 = ICHAR (C2)

  IF ((97 <= IC1) .AND. (IC1 <= 122)) IC1 = IC1 + 32
  IF ((97 <= IC2) .AND. (IC2 <= 122)) IC2 = IC2 + 32

  IF (IC1 /= IC2) THEN
    EQUAL = .FALSE.
    RETURN
  ENDIF
  
ENDDO

END FUNCTION

ELEMENTAL SUBROUTINE UPPER_CASE(OUS,INS)
IMPLICIT NONE
! CONVERT A WORD TO UPPER CASE
CHARACTER (LEN=*) , INTENT(OUT) :: OUS 
CHARACTER (LEN=*) , INTENT(IN) :: INS 
INTEGER :: I,IC,NLEN
NLEN = LEN(INS)
OUS = ''
DO I=1,NLEN
   IC = ICHAR(INS(I:I))
   IF (IC >= 97 .AND. IC < 122) THEN
     OUS(I:I) = CHAR(IC-32)
   ELSE
     OUS(I:I) = INS(I:I)
   ENDIF
END DO
END SUBROUTINE UPPER_CASE

SUBROUTINE COUNTLINES( NLINES, F, ERR )
IMPLICIT NONE
INTEGER, INTENT(OUT) :: NLINES
CHARACTER*(*), INTENT(IN) :: F
INTEGER, INTENT(OUT) :: ERR 
CHARACTER*32 :: STR 


ERR = 0

NLINES = 0 
OPEN( 77, FILE = F, ERR = 888 )

DO
  READ( 77, *, ERR = 888, END = 777 ) STR 
  NLINES = NLINES + 1 
ENDDO

777 CONTINUE

CLOSE( 77 )

RETURN
888 CONTINUE
  ERR = 1
END SUBROUTINE COUNTLINES

END FUNCTION


