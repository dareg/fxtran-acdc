MODULE STACK_MOD

IMPLICIT NONE

TYPE STACK_DATA
  REAL (KIND=4), POINTER :: ZDATA4 (:,:,:,:)
  REAL (KIND=8), POINTER :: ZDATA8 (:,:,:,:)
  INTEGER*8 :: IALIGN
CONTAINS
  PROCEDURE :: INIT => STACK_DATA_INIT
  PROCEDURE :: FINAL => STACK_DATA_FINAL
END TYPE

TYPE STACK
  INTEGER*8 :: L4
  INTEGER*8 :: U4
  INTEGER*8 :: L8
  INTEGER*8 :: U8
END TYPE

TYPE (STACK_DATA) :: YSTACK

PRIVATE
PUBLIC :: STACK, YSTACK, STACK_INIT, STACK_ALLOC

CONTAINS

SUBROUTINE STACK_INIT (SELF, YDSTACK_DATA, KBLOCK, KGPBLKS, YDSTACKBASE) 

!$acc routine seq

TYPE (STACK) :: SELF
TYPE (STACK_DATA), INTENT (IN) :: YDSTACK_DATA
INTEGER, INTENT (IN) :: KBLOCK, KGPBLKS
TYPE (STACK), INTENT (IN), OPTIONAL :: YDSTACKBASE

INTEGER*8 :: IBASE4, IBASE8

INTEGER*8 :: MALIGN, P, K
MALIGN (P, K) = ((P+K-1)/K) * K

IF (PRESENT (YDSTACKBASE)) THEN
  IBASE4 = YDSTACKBASE%L4
  IBASE8 = YDSTACKBASE%L8
ELSE
  IBASE4 = 0
  IBASE8 = 0
ENDIF

SELF%L4 =   IBASE4 + LOC (YDSTACK_DATA%ZDATA4 (1,1,1,1)) + ((INT (KBLOCK, 8) - 1)    &
        * (SIZE (YDSTACK_DATA%ZDATA4,KIND=8) * KIND (YDSTACK_DATA%ZDATA4) - IBASE4)) &
        / INT (KGPBLKS, 8)
SELF%U4 =   IBASE4 + LOC (YDSTACK_DATA%ZDATA4 (1,1,1,1)) + ((INT (KBLOCK, 8)    )    &
        * (SIZE (YDSTACK_DATA%ZDATA4,KIND=8) * KIND (YDSTACK_DATA%ZDATA4) - IBASE4)) &
        / INT (KGPBLKS, 8)

SELF%L8 =   IBASE8 + LOC (YDSTACK_DATA%ZDATA8 (1,1,1,1)) + ((INT (KBLOCK, 8) - 1)    &
        * (SIZE (YDSTACK_DATA%ZDATA8,KIND=8) * KIND (YDSTACK_DATA%ZDATA8) - IBASE8)) &
        / INT (KGPBLKS, 8)
SELF%U8 =   IBASE8 + LOC (YDSTACK_DATA%ZDATA8 (1,1,1,1)) + ((INT (KBLOCK, 8)    )    &
        * (SIZE (YDSTACK_DATA%ZDATA8,KIND=8) * KIND (YDSTACK_DATA%ZDATA8) - IBASE8)) &
        / INT (KGPBLKS, 8)

SELF%L4 = MALIGN(SELF%L4, YDSTACK_DATA%IALIGN)
SELF%L8 = MALIGN(SELF%L8, YDSTACK_DATA%IALIGN)

END SUBROUTINE
 
SUBROUTINE STACK_ALLOC (SELF, KPTR, KSIZE, KKIND, CDFILE)

!$acc routine seq

USE ABOR1_ACC_MOD

TYPE (STACK) :: SELF
INTEGER*8 :: KPTR
INTEGER*8 :: KSIZE
INTEGER   :: KKIND
CHARACTER(LEN=*) :: CDFILE

SELECT CASE (KKIND)
  CASE (4) 

    KPTR = SELF%L4
   
    SELF%L4 = SELF%L4 + 4 * KSIZE
   
    IF (SELF%L4 > SELF%U4) GOTO 999

  CASE (8) 

    KPTR = SELF%L8

    SELF%L8 = SELF%L8 + 8 * KSIZE

    IF (SELF%L8 > SELF%U8) GOTO 999

  CASE DEFAULT

    GOTO 999

END SELECT

RETURN

999 CONTINUE

CALL ABOR1_ACC (CDFILE)

END SUBROUTINE

SUBROUTINE STACK_DATA_INIT (SELF, KLON, KLEV, KSIZE4, KSIZE8, KGPBLKS)

CLASS (STACK_DATA) :: SELF
INTEGER, INTENT (IN) :: KLON, KLEV, KSIZE4, KSIZE8, KGPBLKS

SELF%IALIGN = 8
ALLOCATE (SELF%ZDATA4 (KLON, KLEV, KSIZE4, KGPBLKS))
ALLOCATE (SELF%ZDATA8 (KLON, KLEV, KSIZE8, KGPBLKS))

!$ACC ENTER DATA CREATE (SELF%ZDATA4)
!$ACC ENTER DATA CREATE (SELF%ZDATA8)

!$ACC ENTER DATA CREATE (SELF)
!$ACC UPDATE DEVICE (SELF)
!$ACC ENTER DATA ATTACH (SELF%ZDATA4)
!$ACC ENTER DATA ATTACH (SELF%ZDATA8)

END SUBROUTINE

SUBROUTINE STACK_DATA_FINAL (SELF)

CLASS (STACK_DATA) :: SELF

!$ACC EXIT DATA DETACH (SELF%ZDATA8)
!$ACC EXIT DATA DETACH (SELF%ZDATA4)

!$ACC EXIT DATA DELETE (SELF)

!$ACC EXIT DATA DELETE (SELF%ZDATA8)
!$ACC EXIT DATA DELETE (SELF%ZDATA4)

END SUBROUTINE

END MODULE

